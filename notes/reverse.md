# Reverse Engineering (逆向工程)

逆向工程（Reverse Engineering, RE）是透過分析軟體的執行檔（如二進位檔、ELF、PE 等），來理解程式的運作邏輯、演算法、協定，甚至找出弱點與漏洞的技術。逆向是資安領域中重要技能，常用於破解保護機制、分析惡意軟體、CTF 題目解題
## 基本概念

### 什麼是逆向工程？

- 透過分析已編譯完成的程式碼（二進位檔）來理解其功能與邏輯
- 逆向通常不依賴原始碼，只能透過工具還原程式結構與行為
- 逆向工程可應用於安全分析、漏洞挖掘、破解軟體保護、惡意程式分析

### 逆向流程

1. **收集目標**  
   取得待分析的二進位檔、相關檔案及資訊，包含版本、環境與執行需求等。

2. **靜態分析**  
   不執行程式，利用反組譯器、反編譯器、字串搜尋與二進位分析工具觀察程式架構與資料。

3. **動態分析**  
   執行程式，使用除錯器監控執行流程，記憶體變化與系統呼叫，理解實際運作。

4. **彙整邏輯**  
   將收集的資訊組合，理解演算法、資料流程、控制流程，找出關鍵邏輯與漏洞。

5. **開發利用程式或撰寫報告**  
   根據分析成果撰寫破解程式、利用程式或詳細報告。

---

## 逆向工具介紹

| 工具名稱      | 用途                           | 說明                                      |
|---------------|--------------------------------|-------------------------------------------|
| IDA Pro       | 靜態反組譯                     | 支援多種架構，提供流程圖、函式分析與反編譯功能。     |
| Ghidra        | 靜態反編譯                     | 美國NSA開源工具，強大的反編譯與分析功能。          |
| Radare2       | 靜態/動態分析                 | 開源逆向框架，支援腳本與自訂流程，功能強大。        |
| Hopper        | 靜態反組譯                   | macOS/Linux環境下，操作介面友善。                 |
| Binary Ninja  | 靜態反組譯                   | 界面現代，支援腳本與插件擴展。                    |
| x64dbg        | 動態除錯                      | Windows下強力除錯器，易用且功能完整。              |
| GDB           | 動態除錯                      | Linux命令行除錯器，搭配 pwndbg、peda 強化使用體驗。 |
| pwndbg/peda   | GDB 擴展                     | 增強 GDB 的反匯編、記憶體檢視與除錯效率。          |
| objdump       | 二進位檔反組譯                 | GNU 工具，簡單查看二進位指令與符號。                |
| strace        | 系統呼叫追蹤                  | 監控程序執行時發出的系統呼叫。                      |
| ltrace        | 函式庫呼叫追蹤                | 追蹤程式呼叫的函式庫函數。                          |

---

## 靜態分析

### 反組譯（Disassembly）

- 將機器碼（opcode）轉換成組合語言指令，使人類更容易閱讀。
- 反組譯器會將程式分割成函式和區段，並且生成控制流程圖（CFG）。
- 支援架構包含 x86/x64、ARM、MIPS 等常見指令集。

### 反編譯（Decompilation）

- 將組合語言近似還原為高階語言（通常是 C 語言形式），方便理解演算法和程式邏輯。
- 反編譯結果不會完美，但可快速掌握程式流程。
- 主要工具有 Ghidra、IDA Pro、Binary Ninja。

### ELF/PE 重要區段說明

| 區段名稱    | 功能描述                                       |
|-------------|------------------------------------------------|
| `.text`     | 程式碼段，存放程式執行指令                     |
| `.data`     | 已初始化的全域或靜態資料                        |
| `.bss`      | 未初始化的全域或靜態資料，程式啟動時清零         |
| `.rodata`   | 只讀資料段，常放置字串常量                      |
| `.plt`      | Procedure Linkage Table，函式調用跳板             |
| `.got`      | Global Offset Table，用於動態連結函式地址          |
| `.symtab`   | 符號表，包含函式及變數符號資訊                    |
| `.strtab`   | 字串表，儲存符號名稱的字串                        |

### 常用靜態分析技巧

- **尋找入口點**：如 `main` 函式或 `_start`，是逆向分析的起點。
- **分析函式呼叫與堆疊**：了解函式如何被調用及參數傳遞方式（寄存器或堆疊）。
- **搜尋字串**：利用 `strings` 等工具找出敏感字串（密碼、URL、錯誤訊息等）。
- **識別系統呼叫與函式庫函數**：透過函式名稱判斷程式行為，如 `printf`、`system` 等。

---

## 動態分析

### 除錯（Debugging）

- 使用除錯器（如 GDB、x64dbg）逐步執行程式，觀察寄存器值、記憶體內容及堆疊狀態。
- 透過設置斷點（breakpoints）監控特定指令或函式。
- 可動態修改指令或記憶體，嘗試繞過安全檢查或改變流程。

### 追蹤系統呼叫與函式呼叫

- **strace**：監控程式發出的系統呼叫，如 `open`, `read`, `write`。
- **ltrace**：監控函式庫呼叫，如 `malloc`, `printf`, `system`。

### 動態記憶體分析

- 觀察堆（heap）和棧（stack）狀態，尋找變數與結構的變化。
- 使用 GDB 觀察並修改記憶體內容。
- 進行動態打補丁（patching），例如修改判斷指令以跳過檢查。

---

## 常見反調試與反逆向技術

| 技術名稱            | 說明                                                     | 對策                                                   |
|---------------------|----------------------------------------------------------|--------------------------------------------------------|
| 反除錯檢測          | 程式內嵌入反除錯函式或檢查除錯環境（如 ptrace）            | 使用非侵入式除錯器，或透過修改除錯偵測代碼繞過           |
| 時間檢查            | 程式使用計時器檢測是否執行中斷或延遲，以判斷除錯行為        | 修改時間判斷邏輯或使用同步工具欺騙時間                   |
| 程式碼混淆（Obfuscation） | 使用複雜指令序列、加密、虛擬機技術，使分析困難                  | 逐步執行並分析關鍵邏輯，利用工具解密與還原                |
| 動態加密            | 程式在執行時動態解密程式碼或資料，防止靜態分析                | 動態分析時監控加密與解密過程，截斷或取用解密後記憶體內容    |
| 多層跳轉            | 利用大量無意義跳轉和分支混淆分析流程                          | 使用除錯器追蹤實際執行路徑，記錄指令序列                  |

---

## 二進位格式簡介(ELF / PE)

### ELF (Executable and Linkable Format) — Linux 常見格式

- **ELF Header**：檔案格式基本資訊，包含目標架構、入口點、檔案偏移
- **Program Header Table**：定義如何在記憶體中載入檔案
- **Section Header Table**：記錄各區段名稱、大小與偏移
- **重要區段**：
  - `.text`：程式碼段
  - `.data`：已初始化資料段
  - `.bss`：未初始化資料段
  - `.rodata`：只讀資料段
  - `.plt`、`.got`：動態連結相關

### PE (Portable Executable) — Windows 常見格式

- **DOS Header**：兼容舊版 DOS 的標頭，通常包含跳轉指令
- **PE Header**：PE 格式標頭，包含目標架構、檔案資訊
- **Section Table**：列出各區段與其權限，常見區段有 `.text`、`.data`、`.rdata`、`.rsrc`
- **Import Table / Export Table**：定義匯入與匯出函式清單

---

## 逆向實務技巧

### 理解呼叫堆疊 (Call Stack)

- 函式呼叫會將返回地址與參數推入堆疊。
- 觀察堆疊變化有助於理解參數傳遞與函式邏輯。
- 熟悉 x86-64 的呼叫慣例（前六個整數參數透過寄存器傳遞：`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`）。

### 字串分析

- 利用工具如 `strings`、IDA Pro 的字串視窗搜尋明文資料。
- 找出可能的密碼、錯誤訊息、URL、flag 字串。
- 字串可能被編碼或加密，需要進一步分析。

### 函式庫函數識別

- 常見 C 標準函式包括：
  - `printf()`：格式化輸出
  - `strcpy()`、`strncpy()`：字串拷貝
  - `strcmp()`：字串比較
  - `malloc()`、`free()`：動態記憶體管理
  - `system()`：呼叫系統指令
- 了解這些函式能幫助理解程式邏輯與潛在漏洞。

### 條件跳轉分析

- 條件跳轉指令：
  - `jz` / `je`：當比較結果為相等時跳轉
  - `jne` / `jnz`：不等時跳轉
  - `jmp`：無條件跳轉
- 分析跳轉條件有助判斷程式決策邏輯。

### 簡易 Patch 技巧

- 利用除錯器修改指令：
  - 例如將 `jne` 修改為 `je`，反轉判斷條件。
  - 使用 NOP 指令（`0x90`）覆蓋不想執行的指令。
- Patch 後可跳過驗證、解鎖功能。

---

## 逆向在 CTF 中的應用

### 常見逆向題型

- **CrackMe 類型**  
  破解授權機制、密碼驗證流程。

- **Keygen 類型**  
  生成合法序號或密碼。

- **混淆與加殼二進位檔分析**  
  包含加殼保護、反分析機制。

- **隱藏 flag 的邏輯找尋**  
  分析程式如何生成或驗證 flag。

- **惡意軟體靜態與動態分析題**  
  分析惡意程式行為、C2 通訊協定。

### 典型解題步驟

1. 使用 `strings` 找出明文資訊，包含可能的密碼、flag。
2. 利用反組譯器（IDA Pro、Ghidra）定位主要函式，如授權檢查函式。
3. 動態除錯驗證邏輯判斷，觀察流程及變數變化。
4. 分析加密演算法與校驗流程，理解驗證機制。
5. 撰寫腳本模擬 keygen，或修改程式繞過驗證。

---


